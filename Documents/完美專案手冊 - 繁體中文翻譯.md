返回 [README](../README.md)

# 完美專案手冊 - 繁體中文翻譯

## 專案架構

### 前言

在觀察遊戲程式碼庫之前，我們建議您閱讀整個文件並點擊每個提供的超連結。如果您是初學者——別擔心！我們建議先熟悉本手冊涵蓋的主題，然後逐步在您的遊戲中實施它們。

### 單一入口點 (SEP)

本專案遵循單一入口點 (SEP) 方法論。

1. **首先載入的場景**：始終是 CoreScene，它幾乎是空的。起始場景在 DefaultSceneSelector 腳本中配置。

2. **綁定步驟**：我們使用 Zenject，它提供了方便的依賴注入 (DI) 系統。首先，Zenject 在場景載入後自動連接我們的綁定。這在
   Installers 腳本中完成。每個場景都有其對應的 Installer。
    - 例如：CoreScene 有其 CoreInstaller，LobbyScene 有其 LobbyInstaller。

3. **初始化步驟**：每個場景都有其對應的 Initiator，負責初始化進入和退出點。
    - 例如：CoreScene 有其 CoreInitiator。
    - 注意：CoreInitiator 擁有我們遊戲中唯一的 Start 方法！

## 職責劃分

專案中的腳本可以分為幾個類別，每個都有不同的職責：

### 1. Installer

- 將我們的實例綁定到它們的引用（如上所述）
- 我們總是盡可能綁定到介面！為什麼？
    - a. 某些類必須是介面，因為我們需要在遊戲中將它們綁定到不同的實例。因此，為了在專案中保持一致性，我們即使在非必要的情況下也使用介面。
    - b. 介面清楚地顯示了公共方法和類的目的。
    - c. 可以在單元測試中注入 Mock 實例。
    - d. 這通常是遵循依賴倒置模式的好做法，它指導我們依賴抽象，因為您永遠不知道何時需要它們。

### 2. Initiator

- 為場景提供單一的進入和退出點。

### 3. Commands

- 我們遊戲功能的指揮者。Command 是唯一被允許引用其他功能（Controllers）的類。
- 我們在這個專案中不拋出任何事件，而是執行 Commands。
- Command 是一個簡單的類，有一個 Execute 方法，它透過在多個腳本之間通信，按特定順序呼叫所需的邏輯。
- 注意：當類執行 Command，而 Command 的效果之一是更新該類時，可能會發生循環依賴。為了避免 Commands 中的循環依賴，每個 Command
  從 DIContainer 解析自己的引用。

### 4. MVC

一個用於應用程式和遊戲的軟體架構模式，將我們功能的類分為 3 組：

- **Model（我們使用 'Data'）**：一個只包含資料的簡單類，如欄位、屬性和小的條件方法。我們選擇不在模型中包含任何
  Events/Actions，為此我們有 Commands！
    - 注意：我們不喜歡在遊戲中使用 "model" 這個詞，因為它可能與 3D 模型混淆，所以我們使用 "Data"。

- **View**：表示物件視覺元素/元件的類，如 Sprite/ParticleSystem/3D Model/UI。它總是繼承自 MonoBehaviour 並位於 GameObject
  上。
    - View 只能引用更小的內部 Views。它從不自己呼叫任何東西，只接收指令或將回調傳遞給 Controller。

- **Controller**：我們遊戲功能的 " 大腦 "。它查詢 Model，相應地更新 View，並為複雜流程呼叫 Commands。Controller 是唯一被允許引用其
  Model 和 View 的類。例如：ArrowController 控制 ArrowView。

### 5. Services

- Service 沒有 View，不影響其他腳本。它的唯一職責是為其他腳本提供通用功能。
- Services 可以從 Controllers/Commands/Services 訪問。
- 如果資料需要從多個地方訪問，它不應該儲存在獨立的 DataService 中，這就像一個公共 Model。例如：LevelDataService。

### 6. Factory

- 封裝建立特定物件的邏輯。例如：LevelFactory。

### 7. Utils

- 包含通用、可重用功能的靜態類。

### 8. Extensions

- 提供擴展方法的靜態類。

### 9. GameState

- 表示我們遊戲的一個階段，具有 Enter 和 Exit 方法，用於狀態機模式。我們的遊戲在任何給定時刻只能處於一個 GameState。
- 我們有 2 個 GameStates：LobbyState 和 GamePlayState。

## 專案結構

本專案遵循領域專案結構進行資料夾組織。

### 1. 本專案中的領域：

- **Core**：儲存所有不專用於此專案並可在其他遊戲中使用的腳本/資產。如上所述，CoreScene 是我們遊戲的第一個場景。
- **Game**：儲存所有專用於此特定遊戲並跨多個場景/狀態使用的腳本/資產。GameScene 載入在 CoreScene 之上。
- **Lobby/GamePlay**：代表 GameState 的領域。載入在 CoreScene 之上。

### 2. 程式集定義

- 每個領域都有自己的程式集定義，強制領域之間的引用分離。例如：Core 領域有 CoreAssembly。
- 順便說一下，這減少了我們腳本的編譯時間，因為編譯器只需要重新編譯更改的程式集。

## 設計模式和最佳實踐

### 技術

業界中許多已成為標準的技術可以在本專案中找到：

#### 1. UpdateSubscriptionService (UpdateManager)

- 本專案使用 UpdateManager 模式來提高性能，並允許任何腳本訂閱 Update/FixedUpdate/LateUpdate 方法。

#### 2. 攝影機分離

- 我們使用 2 個攝影機：一個用於繪製世界，另一個用於繪製 UI。這種分離已成為遊戲開發的標準，以確保後處理或任何其他調整不會影響
  UI。

#### 3. 物件池

- 在遊戲過程中頻繁建立的物件被回收以減少記憶體分配。
- 例如：ScoreGainedFXPool 回收 ScoreGainedFXView。

#### 4. 資產載入

- 本專案使用 Unity 的 Addressable 系統動態載入資產。
- 注意：所有資產目前都是專案的一部分，但可以輕易移動到外部伺服器並遠端載入。
- **已知問題**：在有多個並發即時版本的遊戲中（如手機遊戲），如果我們構建附有腳本的預製件，而這些腳本在新版本中被修改，舊版本可能無法載入它們。
- **本專案解決方案**：構建多次包，每個版本一次。每個即時版本將載入其對應的包，不會有問題。
- **替代解決方案**：只構建原始資產（如圖像、3D 模型、音訊檔案或沒有附加腳本的預製件）。

#### 5. 單元測試

- 本專案僅以單元測試覆蓋其核心邏輯服務。這可以擴展到更多類。
- 作為 CI/CD 流水線的一部分，PreBuildUnitTestsValidator 類在任何單元測試失敗時使構建失敗。

#### 6. 動畫

- 本專案使用 Legacy Animation 執行簡單動畫，這顯著更高效——特別是對 UI 物件。注意：如果我們有複雜的動畫物件（如人形角色），它將使用
  Animator 元件。

#### 7. 預製件

- 大多數物件都是預製件，以避免多個開發人員並行工作時的場景衝突。

#### 8. 光照烘焙

- 環境的光照是預烘焙的，以提高執行時性能。代價是構建大小增加約 170MB。

#### 9. 繪製批次合併

- 環境對所有物件使用單一材質，這允許它們在單個繪製呼叫中繪製，提高性能。

#### 10. 著色器

- 我們盡可能使用著色器代替動畫，例如，大廳中水平滾動的山脈，因為著色器計算在 GPU 上並行執行，比基於 CPU 的動畫快得多。

#### 11. 日誌

- 整個程式碼庫都使用日誌監控，使除錯更容易。

#### 12. 補間動畫

- 使用 DoTween 包透過程式碼建立簡單的補間動畫。例如在 ArrowMovementController 中旋轉箭頭。

#### 13. 持久資料加密

- 為了跨遊戲儲存資料，我們使用 Unity 的 PlayerPrefs。
- 為了讓駭客的生活更困難，我們加密資料（見 PlayerPrefsDataPersistence）。
- 注意：儲存玩家資料的理想位置是在遠端、安全的伺服器上。但是，這需要一些重要的前提條件：
    - i. 我們需要管理自己的遠端資料庫或支付雲端儲存服務費用。
    - ii. 為了檢索每個玩家的資料，我們需要玩家的唯一標識符，這意味著我們必須實現登入/認證系統。
    - iii. 這需要一個小的後端伺服器來處理登入驗證。
    - iv. 因此，我們還需要託管該伺服器——本機或支付遠端機器費用。
- 這是商業遊戲避免依賴 PlayerPrefs 的標準方法。但當然，在像這樣的專案中，這實際上是不可行的。

#### 14. 編輯器工具

- 編輯器腳本 LevelTrackViewEditor 是如何透過提前在 LevelTrackView 中快取物件來提高執行時性能的好例子。

## 專案指南

### 編碼標準

1. 本專案主要遵循 Microsoft 的編碼約定。

### 非同步操作

1. 本專案使用 Awaitables——Unity 中非同步操作的新的和改進的原生解決方案。如果您熟悉 UniTask/Task，您會發現它們的語法完全相同。
2. 因為非同步操作預設不捕獲異常，每次我們開始非同步操作時都必須用 try/catch 塊包圍它。
3. 我們向專案中的每個非同步操作傳遞 CancellationTokens，這允許我們在需要時取消操作。
4. 我們遊戲中的每個關卡都有自己的 CancellationToken，儲存在 LevelCancellationTokenService 中，在關卡被釋放時取消。

### 清潔程式碼原則

本專案採用清潔程式碼原則——但只有那些我們發現真正有效的。

1. **編寫自文件化程式碼**
    - 程式碼應該易於閱讀，使用有意義的名稱和可重用的函式，無需註釋就能講述其故事。
    - 註釋僅用於沒有明確替代方案的警告。

2. **單一職責原則 (SRP)**
    - 每個類、方法或模組只應有一個改變的理由。

3. **小的、專注的函式和類**

4. **避免深度 if 嵌套**
    - 盡可能保持分支邏輯淺。

5. **避免 switch 語句**
    - 用適當的抽象取代它們。

6. **DRY (不要重複自己)**
    - 避免程式碼重複，但僅在非必要時。

7. **不可變的 Get 方法**
    - Get 方法永遠不應該修改內部狀態或造成副作用。

8. **沒有 " 魔法數字 "**
    - 所有常數變數都儲存為 const。